using P4est_wrapper
using GridapP4est
using Gridap
using PartitionedArrays
using GridapDistributed
using MPI

# Generate a local numbering of vertices that includes hanging vertices 
# Generate a local numbering of faces out of the one generated by vertices (automatic? to confirm)

# Establish the correspondence among local numbering of vertices and p4est global numbering 
# Establish the correspondence among local numbering of faces and p4est global numbering 

# Generate a global numbering of (regular,hanging) vertices?
# Generate a global numbering of (regular,hanging) faces?


## Better to use a C-enum. But I did not use it in order to keep the Julia
## version of this C example as simple as possible
const nothing_flag = Cint(0)
const refine_flag = Cint(1)

## Refine those cells with even identifier    (0,2,4,6,8,...)
## Leave untouched cells with odd identifier  (1,3,5,7,9,...)
function allocate_and_set_refinement_and_coarsening_flags(forest_ptr::Ptr{p4est_t})
  forest = forest_ptr[]
  tree = p4est_tree_array_index(forest.trees, 0)[]
  return [i != 1 ? nothing_flag : refine_flag for i = 1:tree.quadrants.elem_count]
end

## Global variable which is updated across calls to init_fn_callback_2d
current_quadrant_index = Cint(0)
## Global variable which is updated across calls to refine_replace_callback_2d
num_calls = Cint(0)

# This C callback function is called once per quadtree quadrant. Here we are assuming
# that p4est->user_pointer has been set prior to the first call to this call
# back function to an array of ints with as many entries as forest quadrants. This call back function
# initializes the quadrant->p.user_data void * pointer of all quadrants such that it
# points to the corresponding entry in the global array mentioned in the previous sentence.
function init_fn_callback_2d(forest_ptr::Ptr{p4est_t},
  which_tree::p4est_topidx_t,
  quadrant_ptr::Ptr{p4est_quadrant_t})
  @assert which_tree == 0
  # Extract a reference to the first (and uniquely allowed) tree
  forest = forest_ptr[]
  tree = p4est_tree_array_index(forest.trees, 0)[]
  quadrant = quadrant_ptr[]
  q = P4est_wrapper.p4est_quadrant_array_index(tree.quadrants, current_quadrant_index)
  @assert p4est_quadrant_compare(q, quadrant_ptr) == 0
  user_data = unsafe_wrap(Array, Ptr{Cint}(forest.user_pointer), current_quadrant_index + 1)[current_quadrant_index+1]
  unsafe_store!(Ptr{Cint}(quadrant.p.user_data), user_data, 1)
  global current_quadrant_index = (current_quadrant_index + 1) % (tree.quadrants.elem_count)
  return nothing
end

const init_fn_callback_2d_c = @cfunction(init_fn_callback_2d, Cvoid, (Ptr{p4est_t}, p4est_topidx_t, Ptr{p4est_quadrant_t}))


function refine_callback_2d(::Ptr{p4est_t},
  which_tree::p4est_topidx_t,
  quadrant_ptr::Ptr{p4est_quadrant_t})
  @assert which_tree == 0
  quadrant = quadrant_ptr[]
  return Cint(unsafe_wrap(Array, Ptr{Cint}(quadrant.p.user_data), 1)[] == refine_flag)
end

const refine_callback_2d_c = @cfunction(refine_callback_2d, Cint, (Ptr{p4est_t}, p4est_topidx_t, Ptr{p4est_quadrant_t}))

MPI.Init()
parts = get_part_ids(MPIBackend(), 1)
# run(parts, (1, 1))
# MPI.Finalize()

# This is for debuging
Dc=2
domain = (0, 1, 0, 1)
subdomains = (1, 1)
coarse_model = CartesianDiscreteModel(domain, subdomains)
model = OctreeDistributedDiscreteModel(parts, coarse_model, 1)

# TO-DO: refine and coarsening flags should be an input argument, instead of being hard-coded
# function adapt_non_conforming_work_in_progress(model::OctreeDistributedDiscreteModel{Dc,Dp}) where {Dc,Dp}
# Copy and refine input p4est
ptr_new_pXest = GridapP4est.pXest_copy(Val{Dc}, model.ptr_pXest)

user_data = allocate_and_set_refinement_and_coarsening_flags(ptr_new_pXest)
p4est_reset_data(ptr_new_pXest, Cint(sizeof(Cint)), init_fn_callback_2d_c, pointer(user_data))
p4est_refine_ext(ptr_new_pXest, 0, -1, refine_callback_2d_c, C_NULL, C_NULL)
p4est_partition(ptr_new_pXest, 1, C_NULL)

p4est_vtk_write_file(ptr_new_pXest, C_NULL, string("adapted_forest"))

ptr_pXest_ghost = GridapP4est.setup_pXest_ghost(Val{Dc}, ptr_new_pXest)
ptr_pXest_lnodes = GridapP4est.p4est_lnodes_new(ptr_new_pXest, ptr_pXest_ghost, -2)

dmodel,non_conforming_glue=setup_non_conforming_distributed_discrete_model(Val{2},
                                                       parts,
                                                       coarse_model,
                                                       model.ptr_pXest_connectivity,
                                                       ptr_new_pXest,
                                                       ptr_pXest_ghost,
                                                       ptr_pXest_lnodes)

# FE Spaces
order=1
reffe = ReferenceFE(lagrangian,Float64,order)
V = TestFESpace(dmodel,reffe,dirichlet_tags="boundary")
U = TrialFESpace(V)   

sDOF_to_dof, sDOF_to_dofs=generate_symbolic_constraints(model.dmodel, V, reffe, non_conforming_glue)
println(sDOF_to_dof)
println(sDOF_to_dofs)

function generate_symbolic_constraints(dmodel, V,reffe,non_conforming_glue)
  gridap_cells_vertices,
  num_regular_vertices, num_hanging_vertices,
  hanging_vertices_owner_cell_and_lface,
  gridap_cells_faces,
  num_regular_faces, num_hanging_faces,
  hanging_faces_owner_cell_and_lface = non_conforming_glue

  sDOF_to_dof, sDOF_to_dofs = map_parts(gridap_cells_vertices,
            num_regular_vertices,
            num_hanging_vertices,
            hanging_vertices_owner_cell_and_lface,
            gridap_cells_faces,
            num_regular_faces,
            num_hanging_faces,
            hanging_faces_owner_cell_and_lface, model.dmodel.models, V.spaces) do gridap_cells_vertices,
                                                   num_regular_vertices, num_hanging_vertices,
                                                   hanging_vertices_owner_cell_and_lface,
                                                   gridap_cells_faces,
                                                   num_regular_faces, num_hanging_faces,
                                                   hanging_faces_owner_cell_and_lface,
                                                   model, V
   
      # Locate for each hanging vertex a cell to which it belongs 
      # and local position within that cell 
      hanging_vertices_to_cell    = Vector{Int}(undef, num_hanging_vertices) 
      hanging_vertices_to_lvertex = Vector{Int}(undef, num_hanging_vertices)
      for cell=1:length(gridap_cells_vertices)
        s=gridap_cells_vertices.ptrs[cell]
        e=gridap_cells_vertices.ptrs[cell+1]
        l=e-s
        for j=1:l
          vid=gridap_cells_vertices.data[s+j-1]
          if vid>num_regular_vertices 
            vid_hanging=vid-num_regular_vertices
            hanging_vertices_to_cell[vid_hanging]=cell
            hanging_vertices_to_lvertex[vid_hanging]=j
          end 
        end 
      end

      basis, reffe_args,reffe_kwargs = reffe
      cell_reffe = ReferenceFE(model,basis,reffe_args...;reffe_kwargs...)
      reffe_cell = first(cell_reffe)

      cell_dof_ids  = get_cell_dof_ids(V)
      face_own_dofs = Gridap.ReferenceFEs.get_face_own_dofs(reffe_cell)
      face_dofs     = Gridap.ReferenceFEs.get_face_dofs(reffe_cell)


      ptrs=Vector{Int}(undef, num_hanging_vertices+1)
      ptrs[1]=1
      for vid_hanging=1:num_hanging_vertices
        (_,ocell_lface)=hanging_vertices_owner_cell_and_lface[vid_hanging]
        ptrs[vid_hanging+1] = ptrs[vid_hanging] + length(face_dofs[ocell_lface])
      end 
      data=Vector{Int}(undef, ptrs[num_hanging_vertices+1]-1)
      for vid_hanging=1:num_hanging_vertices
        (ocell,ocell_lface)=hanging_vertices_owner_cell_and_lface[vid_hanging]
        s=ptrs[vid_hanging]
        e=ptrs[vid_hanging+1]-1
        for (j,ldof) in enumerate(face_dofs[ocell_lface])
          data[s+j-1]=cell_dof_ids[ocell][ldof]
        end
      end 
      hanging_vertices_owner_face_dofs=Gridap.Arrays.Table(data,ptrs)

      sDOF_to_dof  = Int[]
      sDOF_to_dofs = Vector{Int}[]
      for vid_hanging=1:num_hanging_vertices
         # Go over the dofs of hanging_vertices_to_cell[vid_hanging]
         # on hanging_vertices_to_lvertex lvertx
         cell=hanging_vertices_to_cell[vid_hanging]
         lvertex=hanging_vertices_to_lvertex[vid_hanging]
         for ldof in face_own_dofs[lvertex]
           push!(sDOF_to_dof,cell_dof_ids[cell][ldof])
           push!(sDOF_to_dofs,hanging_vertices_owner_face_dofs[vid_hanging])
         end 
      end
      sDOF_to_dof, sDOF_to_dofs
    end 
end

# end


using Gridap
using Gridap.ReferenceFEs
function _h_refined_reffe(reffe::Tuple{<:Lagrangian,Any,Any})
  (reffe[1],(reffe[2][1],2*reffe[2][2]),reffe[3])
end

order=2
reffe = ReferenceFE(lagrangian,Float64,order)
basis, reffe_args,reffe_kwargs = reffe
cell_reffe = ReferenceFE(model,basis,reffe_args...;reffe_kwargs...)
reffe_cell = first(cell_reffe)

h_refined_reffe = _h_refined_reffe(reffe)
model = Gridap.Geometry.CartesianDiscreteModel((0,1,0,1),(10,10))


basis, reffe_args,reffe_kwargs = h_refined_reffe
cell_reffe_h_refined = ReferenceFE(model,basis,reffe_args...;reffe_kwargs...)
reffe_cell_h_refined = first(cell_reffe_h_refined)
dof_basis_h_refined = get_dof_basis(reffe_cell_h_refined)

sfuns=Gridap.ReferenceFEs.get_shapefuns(reffe_cell)
evaluate(dof_basis_h_refined,sfuns)
