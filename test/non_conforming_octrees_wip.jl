using P4est_wrapper
using GridapP4est
using Gridap
using PartitionedArrays
using GridapDistributed
using MPI
using Gridap.FESpaces

# Generate a local numbering of vertices that includes hanging vertices 
# Generate a local numbering of faces out of the one generated by vertices (automatic? to confirm)

# Establish the correspondence among local numbering of vertices and p4est global numbering 
# Establish the correspondence among local numbering of faces and p4est global numbering 

# Generate a global numbering of (regular,hanging) vertices?
# Generate a global numbering of (regular,hanging) faces?


## Better to use a C-enum. But I did not use it in order to keep the Julia
## version of this C example as simple as possible
const nothing_flag = Cint(0)
const refine_flag = Cint(1)

## Refine those cells with even identifier    (0,2,4,6,8,...)
## Leave untouched cells with odd identifier  (1,3,5,7,9,...)
function allocate_and_set_refinement_and_coarsening_flags(forest_ptr::Ptr{p4est_t})
  forest = forest_ptr[]
  tree = p4est_tree_array_index(forest.trees, 0)[]
  return [i != 1 ? nothing_flag : refine_flag for i = 1:tree.quadrants.elem_count]
end

MPI.Init()
parts = get_part_ids(MPIBackend(), 1)
# run(parts, (1, 1))
# MPI.Finalize()

# This is for debuging
Dc=2
domain = (0, 1, 0, 1)
subdomains = (1, 1)
coarse_model = CartesianDiscreteModel(domain, subdomains)
model = OctreeDistributedDiscreteModel(parts, coarse_model, 1)

ref_coarse_flags=map_parts(parts) do _
   allocate_and_set_refinement_and_coarsening_flags(model.ptr_pXest)
end 
dmodel,non_conforming_glue=refine(model,ref_coarse_flags)   

p4est_vtk_write_file(dmodel.ptr_pXest, C_NULL, string("adapted_forest"))

# FE Spaces
order=4
reffe = ReferenceFE(lagrangian,Float64,order)
V = TestFESpace(dmodel,reffe,dirichlet_tags="boundary")
U = TrialFESpace(V)   

function _h_refined_reffe(reffe::Tuple{<:Lagrangian,Any,Any})
  (reffe[1],(reffe[2][1],2*reffe[2][2]),reffe[3])
end

basis, reffe_args,reffe_kwargs = reffe
cell_reffe = ReferenceFE(QUAD,basis,reffe_args...;reffe_kwargs...)
reffe_cell = cell_reffe

h_refined_reffe = _h_refined_reffe(reffe)
basis, reffe_args,reffe_kwargs = h_refined_reffe
cell_reffe_h_refined = ReferenceFE(QUAD,basis,reffe_args...;reffe_kwargs...)
reffe_cell_h_refined = cell_reffe_h_refined

dof_basis_h_refined = Gridap.CellData.get_dof_basis(reffe_cell_h_refined)

coarse_shape_funs=Gridap.ReferenceFEs.get_shapefuns(reffe_cell)
ref_constraints=evaluate(dof_basis_h_refined,coarse_shape_funs)


rr = Gridap.Adaptivity.RedRefinementRule(QUAD)
face_subface_ldof_to_cell_ldof = Gridap.Adaptivity.coarse_nodes_above_fine_nodes(rr,(order,order),1)


# To-think: might this info go to the glue? 
# If it is required in different scenarios, I would say it may make sense
function _generate_hanging_faces_to_cell_and_lface(num_regular_faces, 
                                                   num_hanging_faces, 
                                                   gridap_cell_faces)
  # Locate for each hanging vertex a cell to which it belongs 
  # and local position within that cell 
  hanging_faces_to_cell = Vector{Int}(undef, num_hanging_faces) 
  hanging_faces_to_lface = Vector{Int}(undef, num_hanging_faces)
  for cell=1:length(gridap_cell_faces)
    s=gridap_cell_faces.ptrs[cell]
    e=gridap_cell_faces.ptrs[cell+1]
    l=e-s
    for j=1:l
      fid=gridap_cell_faces.data[s+j-1]
      if fid>num_regular_faces
        fid_hanging=fid-num_regular_faces
        hanging_faces_to_cell[fid_hanging]=cell
        hanging_faces_to_lface[fid_hanging]=j
      end 
    end 
  end
  hanging_faces_to_cell, hanging_faces_to_lface
end


function _generate_hanging_faces_owner_face_dofs(num_hanging_faces, 
                                                 face_dofs,
                                                 hanging_faces_glue,
                                                 cell_dof_ids)
  
  cache = array_cache(cell_dof_ids)

  ptrs=Vector{Int}(undef, num_hanging_faces+1)
  ptrs[1]=1
  for fid_hanging=1:num_hanging_faces
    glue=hanging_faces_glue[fid_hanging]
    ocell_lface=glue[2]
    ptrs[fid_hanging+1] = ptrs[fid_hanging] + length(face_dofs[ocell_lface])
  end 
  data_owner_face_dofs=Vector{Int}(undef, ptrs[num_hanging_faces+1]-1)
  data_owner_face_ldofs=Vector{Int}(undef, ptrs[num_hanging_faces+1]-1)
  for fid_hanging=1:num_hanging_faces
    glue=hanging_faces_glue[fid_hanging]
    ocell=glue[1]
    ocell_lface=glue[2]
    s=ptrs[fid_hanging]
    e=ptrs[fid_hanging+1]-1
    current_cell_dof_ids = getindex!(cache, cell_dof_ids, ocell)
    for (j,ldof) in enumerate(face_dofs[ocell_lface])
      data_owner_face_dofs[s+j-1]=current_cell_dof_ids[ldof]
      data_owner_face_ldofs[s+j-1]=ldof
    end
  end 
  Gridap.Arrays.Table(data_owner_face_dofs , ptrs), 
     Gridap.Arrays.Table(data_owner_face_ldofs, ptrs)
end

function generate_constraints(dmodel, 
                              V,
                              reffe,
                              non_conforming_glue,
                              ref_constraints, 
                              face_subface_ldof_to_cell_ldof)
  num_regular_faces,
  num_hanging_faces,
  gridap_cell_faces,
  hanging_faces_glue = non_conforming_glue

  sDOF_to_dof, sDOF_to_dofs, sDOF_to_coeffs = map_parts(gridap_cell_faces[1],
                                                        num_regular_faces[1],
                                                        num_hanging_faces[1],
                                                        hanging_faces_glue[1],
                                                        gridap_cell_faces[2],
                                                        num_regular_faces[2],
                                                        num_hanging_faces[2],
                                                        hanging_faces_glue[2], 
                                                        model.dmodel.models, V.spaces) do gridap_cell_vertices,
                                                        num_regular_vertices, num_hanging_vertices,
                                                        hanging_vertices_owner_cell_and_lface,
                                                        gridap_cell_faces,
                                                        num_regular_faces, num_hanging_faces,
                                                        hanging_faces_owner_cell_and_lface,
                                                        model, V
   
      # Locate for each hanging vertex a cell to which it belongs 
      # and local position within that cell 
      hanging_vertices_to_cell,    
      hanging_vertices_to_lvertex = _generate_hanging_faces_to_cell_and_lface(num_regular_vertices, 
                                                                              num_hanging_vertices, 
                                                                              gridap_cell_vertices)


      # Locate for each hanging facet a cell to which it belongs 
      # and local position within that cell 
      hanging_faces_to_cell,    
      hanging_faces_to_lface = _generate_hanging_faces_to_cell_and_lface(num_regular_faces, 
                                                                         num_hanging_faces, 
                                                                         gridap_cell_faces)                                                                        

      basis, reffe_args,reffe_kwargs = reffe
      cell_reffe = ReferenceFE(QUAD,basis,reffe_args...;reffe_kwargs...)
      reffe_cell = cell_reffe

      cell_dof_ids  = get_cell_dof_ids(V)
      face_own_dofs = Gridap.ReferenceFEs.get_face_own_dofs(reffe_cell)
      face_dofs     = Gridap.ReferenceFEs.get_face_dofs(reffe_cell)

      hanging_vertices_owner_face_dofs, 
      hanging_vertices_owner_face_ldofs = _generate_hanging_faces_owner_face_dofs(num_hanging_vertices, 
                                              face_dofs,
                                              hanging_vertices_owner_cell_and_lface,
                                              cell_dof_ids)

      hanging_faces_owner_face_dofs, 
      hanging_faces_owner_face_ldofs = _generate_hanging_faces_owner_face_dofs(num_hanging_faces, 
                                              face_dofs,
                                              hanging_faces_owner_cell_and_lface,
                                              cell_dof_ids)

      sDOF_to_dof    = Int[]
      sDOF_to_dofs   = Vector{Int}[]
      sDOF_to_coeffs = Vector{Float64}[]

      basis, reffe_args,reffe_kwargs = reffe
      face_reffe = ReferenceFE(SEGMENT,basis,reffe_args...;reffe_kwargs...)
      Dc = 2
      hanging_lvertex_within_first_subface = 2^(Dc-1)
      subface_own_dofs = Gridap.ReferenceFEs.get_face_own_dofs(face_reffe)
      vertex_subface_own_dofs = subface_own_dofs[hanging_lvertex_within_first_subface]
      num_vertices = 2^Dc
      num_faces = 2*Dc

      for vid_hanging=1:num_hanging_vertices
         # Go over the dofs of hanging_vertices_to_cell[vid_hanging]
         # on hanging_vertices_to_lvertex lvertx
         cell=hanging_vertices_to_cell[vid_hanging]
         lvertex=hanging_vertices_to_lvertex[vid_hanging]
         (_,ocell_lface)=hanging_vertices_owner_cell_and_lface[vid_hanging]
         ocell_lface = ocell_lface - num_faces
         for ((ldof,dof),ldof_subface) in zip(enumerate(face_own_dofs[lvertex]),vertex_subface_own_dofs)
           push!(sDOF_to_dof,cell_dof_ids[cell][dof])
           push!(sDOF_to_dofs,hanging_vertices_owner_face_dofs[vid_hanging])
           coeffs=Vector{Float64}(undef,length(hanging_vertices_owner_face_ldofs[vid_hanging]))
           for (i,ldof_coarse) in enumerate(hanging_vertices_owner_face_ldofs[vid_hanging])
            coeffs[i]=ref_constraints[face_subface_ldof_to_cell_ldof[ocell_lface][1][ldof_subface],ldof_coarse]
           end
           push!(sDOF_to_coeffs,coeffs) 
         end 
      end

      subface_own_dofs = subface_own_dofs[end]
      for fid_hanging=1:num_hanging_faces
        cell=hanging_faces_to_cell[fid_hanging]
        lface=hanging_faces_to_lface[fid_hanging]
        _,ocell_lface,subface=hanging_faces_owner_cell_and_lface[fid_hanging]
        ocell_lface = ocell_lface - num_faces
        for ((ldof,dof),ldof_subface) in zip(enumerate(face_own_dofs[num_vertices+lface]),subface_own_dofs)
          push!(sDOF_to_dof,cell_dof_ids[cell][dof])
          push!(sDOF_to_dofs,hanging_faces_owner_face_dofs[fid_hanging])
          coeffs=Vector{Float64}(undef,length(hanging_faces_owner_face_ldofs[fid_hanging]))
          for (i,ldof_coarse) in enumerate(hanging_faces_owner_face_ldofs[fid_hanging])
           coeffs[i]=ref_constraints[face_subface_ldof_to_cell_ldof[ocell_lface][subface][ldof_subface],ldof_coarse]
          end
          push!(sDOF_to_coeffs,coeffs) 
        end 
     end


      # TO-DO: the tables can be generated more efficiently
      sDOF_to_dof, Gridap.Arrays.Table(sDOF_to_dofs), Gridap.Arrays.Table(sDOF_to_coeffs)
    end 
end

sDOF_to_dof, sDOF_to_dofs,sDOF_to_coeffs=
    generate_constraints(model.dmodel, V, reffe, 
                        non_conforming_glue, ref_constraints, face_subface_ldof_to_cell_ldof)
println(sDOF_to_dof)
println(sDOF_to_dofs)
println(sDOF_to_coeffs)

# Define manufactured functions
u(x) = x[1]*x[2]+x[2]^2
f(x) = -Δ(u)(x)

map_parts(dmodel.dmodel.models,V.spaces,U.spaces,sDOF_to_dof,sDOF_to_dofs,sDOF_to_coeffs) do model,V,U,sDOF_to_dof,sDOF_to_dofs,sDOF_to_coeffs
  Vc = FESpaceWithLinearConstraints(
    sDOF_to_dof,
    sDOF_to_dofs,
    sDOF_to_coeffs,
    V)
  Uc = TrialFESpace(Vc,u)

  # Define integration mesh and quadrature
  degree = 2*order+1
  Ω = Triangulation(model)
  dΩ = Measure(Ω,degree)

  a(u,v) = ∫( ∇(v)⊙∇(u) )*dΩ
  b(v) = ∫(v*f)*dΩ

  # op = AffineFEOperator(a,b,U,V0)
  op = AffineFEOperator(a,b,Uc,Vc)
  uh = solve(op)

  # Define exact solution and error
  e = u - uh

  # Compute errors
  el2 = sqrt(sum( ∫( e*e )*dΩ ))
  eh1 = sqrt(sum( ∫( e*e + ∇(e)⋅∇(e) )*dΩ ))

  tol=1e-8
  @assert el2 < tol
  @assert eh1 < tol
end 



